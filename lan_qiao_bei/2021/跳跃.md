# 跳跃 2021蓝桥杯模拟赛 = 动态规划
## 题目描述
    小蓝在一个 n 行 m 列的方格图中玩一个游戏。

    开始时，小蓝站在方格图的左上角，即第 1 行第 1 列。

    小蓝可以在方格图上走动，走动时，如果当前在第 r 行第 c 列，他不能走到行号比 r 小的行，也不能走到列号比 c 小的列。同时，他一步走的直线距离不超过 3。

    例如，如果当前小蓝在第 3 行第 5 列
    
    他下一步可以走到
    
    第 3 行第 6 列、第 3 行第 7 列、第 3 行第 8 列、
    
    第 4 行第 5 列、第 4 行第 6 列、第 4 行第 7 列、
    
    第 5 行第 5 列、第 5 行第 6 列、第 6 行第 5 列之一。

    小蓝最终要走到第 n 行第 m 列。

    在图中，有的位置有奖励，走上去即可获得，
    
    有的位置有惩罚，走上去就要接受惩罚。
    
    奖励和惩罚最终抽象成一个权值，奖励为正，惩罚为负。

    小蓝希望，从第 1 行第 1 列走到第 n 行第 m 列后，
    
    总的权值和最大。请问最大是多少？
----

 输入描述

    输入的第一行包含两个整数 n, m表示图的大小。

    接下来 n 行，每行 m 个整数，表示方格图中每个点的权值。

    其中，1≤n≤100，?10^4≤权值≤10^4
    
----
输出描述
                       
    输出一个整数，表示最大权值和。



输入输出样例

    示例 1

    输入
            3 5
            -4 -5 -10 -3 1
            7 5 -9 3 -10
            10 -2 6 -10 -4
    输出
            15


运行限制  

    最大运行时间：1s
    最大运行内存: 128M

## 解题思路

<font face = "隶书" size = 6 color = red >典型的动态规划题</font>

<font color = blue >**动态规划五步法:**</font>
1. 确定dp数组以及下标含义

        dp[i][j]表示在(i,j)位置上时,可以获得的最大价值 

2. 确定递推公式

        题目给出的是小蓝可以向下或向右最多走3步,
        
        所以,在3步之内的都可以一步到达

        因此就需要找出在这几个可以到达(i,j)点的dp值,
        
        比较他们的大小,从而得到最大的值,
        
        然后再加上本身在(i,j)点需要加上的值,
        
        即为在该点最大的dp值

        例如:

        在不考虑边界时:
        
        dp[i][j] = grid[i][j] + max(dp[i-1][j]
                                    dp[i-2][j]
                                    dp[i-3][j]
                                    dp[i][j-1]
                                    dp[i][j-2]
                                    dp[i][j-3])

3. 初始化dp数组

        dp[0][0] = 起始点的值

4. 确定遍历顺序

        由上述公式可以看出,都是从上面或者左面推导出来的

        因此,遍历顺序为从上到下,从左到右

5. 检查dp数组

        基本正确

**AC代码**

```cpp
/*---------------------------------------------------------------
              Proverb  : Make a little progress every day         
              AUthor   : CONG   XING                               
              Question : 跳跃                              
              Data     : 2022 - 01 - 20
              Time     : 23:10:20
----------------------------------------------------------------*/
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
int grid[105][105];
int x[3] = {-1,-2,-3};
int y[3] = {-1,-2,-3};
int dp[105][105];
int main()
{               
    int n,m;
    cin>>n>>m;
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < m; j++)
        {
            cin>>grid[i][j];
        }
    }
    dp[0][0] = grid[0][0];
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < m; j++)
        {
            int maxx = INT_MIN;
            vector<int> ve;
            for (int k = 0; k < 3; k++)
            {
                if(i+x[k]>=0)
                {
                    ve.push_back(dp[i+x[k]][j]);
                }
                if(j+y[k]>=0)
                {
                    ve.push_back(dp[i][j+y[k]]);
                }
            }
            sort(ve.begin(),ve.end());
            if(ve.empty()!=1)
            {
                maxx = ve[ve.size()-1];
                dp[i][j] = grid[i][j] + maxx;
            }
            ve.clear();
        }
    }
    // for (int i = 0; i < n; i++)
    // {
    //     for (int j = 0; j < m; j++)
    //     {
    //         cout<<dp[i][j]<<' ';  
    //     }
    //     cout<<endl;
    // }    
    cout<<dp[n-1][m-1];           
    return 0;                   
}

```

